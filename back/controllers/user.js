import crypto from "crypto";
import jwt from "jsonwebtoken";
import mongoose from "mongoose";

import User from "../models/user.js";

/**
 * This function takes care of giving a user login after performing checks on the noSQL Atlas database.
 * A token corresponding to one hour is generated and the salt of the password stored in the DB is taken,
 * then the hash is stored in another variable and the algorithm Password-based key derivation function 2
 * (PBKDF2) is run with the decomposed password.
 * @param  {Request} req It is in charge of attending the incoming request given an Email and password.
 * @param  {Response} res Responsible for responding to the request. 200 OK to return a token with an existing user. 404 In case user with requested email does not exist. 400 Bad credentials.
 */
export const signin = async (req, res) => {
  const { email, password } = req.body;

  try {
    const existingUser = await User.findOne({ email });
    if (!existingUser) {
      return res.status(404).json({ message: "El usuario no existe" });
    }

    let isPasswordCorrect = false;
    const originalHash = existingUser.password.split("$")[1];
    const salt = existingUser.password.split("$")[0];
    const hash = crypto
      .pbkdf2Sync(password, salt, 2048, 32, "sha512")
      .toString("hex");

    if (hash === originalHash) {
      isPasswordCorrect = true;
    }

    if (!isPasswordCorrect) {
      return res
        .status(400)
        .json({ message: "Verifica de nuevo tus credenciales." });
    }

    const token = jwt.sign(
      { email: existingUser.email, id: existingUser._id },
      "test",
      { expiresIn: "1h" }
    );

    await User.findByIdAndUpdate(
      existingUser._id,
      { $set: { lastConnectionDate: Date.now() } },
      { new: true }
    );

    res.status(200).json({ result: existingUser, token });
  } catch (error) {
    res.status(500).json({ message: "Ups! Algo no funcion칩" });
  }
};

/**
 * This function takes care of creating a user after performing checks on the noSQL Atlas database.
 * A token corresponding to one hour is generated and the password is encrypted using the NodeJS cryptographic api; Crypto.
 * The salt is generated with 16 random bytes of extension and later nested a "$" with the key generated by the algorithm Password-based key
 * derivation function 2 (PBKDF2)
 * @param  {Request} req It is in charge of attending the incoming request given an Email and password.
 * @param  {Response} res Responsible for responding to the request. 200 OK to return a token with an existing user. 400 Bad credentials.
 */
export const signup = async (req, res) => {
  const { email, password, confirmPassword, firstName, lastName } = req.body;

  try {
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: "El correo ingresado ya existe" });
    }

    if (password !== confirmPassword) {
      return res.status(400).json({ message: "Las contrase침as no coinciden" });
    }

    const salt = crypto.randomBytes(16).toString("hex");
    const hash = crypto
      .pbkdf2Sync(password, salt, 2048, 32, "sha512")
      .toString("hex");
    const hashedPassword = [salt, hash].join("$");

    const result = await User.create({
      email,
      role: "common",
      lastConnectionDate: new Date().toISOString(),
      password: hashedPassword,
      name: `${firstName} ${lastName}`,
    });

    const token = jwt.sign({ email: result.email, id: result._id }, "test", {
      expiresIn: "1h",
    });
    res.status(201).json({ result, token });
  } catch (error) {
    res.status(500).json({ message: "Ups! Algo no funcion칩" });
  }
};

/**
 * This function takes care of creating a user after performing checks on the noSQL Atlas database.
 * The password is encrypted using the NodeJS cryptographic api; Crypto. The salt is generated with
 * 16 random bytes of extension and later nested a "$" with the key generated by the algorithm Password-based key
 * derivation function 2 (PBKDF2)
 * @param  {Request} req It is in charge of attending the incoming request given an Email and password.
 * @param  {Response} res Responsible for responding to the request. 200 OK to return a token with an existing user. 400 Bad credentials.
 */
export const resetPassword = async (req, res) => {
  const { id } = req.params;

  const { password } = req.body;

  try {
    const salt = crypto.randomBytes(16).toString("hex");
    const hash = crypto
      .pbkdf2Sync(password, salt, 2048, 32, "sha512")
      .toString("hex");
    const hashedPassword = [salt, hash].join("$");

    await User.findByIdAndUpdate(
      id,
      { $set: { password: hashedPassword } },
      { new: true }
    );

    res.json(password);
  } catch (error) {
    res.status(500).json({ message: "Ups! parece que algo fall칩" });
    console.log(error);
  }
};

/**
 * This function is responsible for searching in the Atlas noSQL database, the list of users
 * @param  {Response} res Responsible for responding to the request. 200 OK to return all users. 500 Failed to make request
 */
export const getusers = async (req, res) => {
  try {
    const users = await User.find().sort({ _id: -1 });

    res.status(200).json({ data: users });
  } catch (error) {
    res.status(500).json({ error });
    console.log(error);
  }
};

/**
 * This function is responsible for deleting a user given by an id, in the noSQL Atlas database.
 * @param  {Request} req It is in charge of attending the incoming request according to a user id that it receives.
 * @param  {Response} res Responsible for responding to the request. 200 OK to return the successful message. 500 Something went wrong.
 */
export const deleteuser = async (req, res) => {
  const id = req.params.id;

  try {
    if (!mongoose.Types.ObjectId.isValid(id))
      return res.status(404).send(`Ups! No existe un usuario con id: ${id}`);

    await User.findByIdAndRemove(id);
    res.status(200).json({ message: "Usuario eliminado satisfactoriamente" });
  } catch (error) {
    res.status(500).json({ error });
    console.log(error);
  }
};
